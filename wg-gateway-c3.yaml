esphome:
  name: "wg-gateway-c3"
  friendly_name: "Wiegand-Gateway-C3"
  project:
    name: "N-Software.Wiegand-Gateway"
    version: "2.1.4"
  on_boot:
    priority: -10
    then:
      - text_sensor.template.publish: {id: last_access_event, state: "---"}
      - text_sensor.template.publish: {id: gateway_status, state: "Bereit"}
      - text_sensor.template.publish: {id: raw_scan_preview, state: "---"}
      - text_sensor.template.publish:
          id: terminal_location_display
          state: !lambda "return id(terminal_location_storage);"
      - text.set:
          id: location_input
          value: ""

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

# Erforderlich für die Netzwerk-Initialisierung unter esp-idf
network:

# ================= KOMMUNIKATION ================= 
logger:
  level: DEBUG

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true

mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_user
  password: !secret mqtt_password
  id: mqtt_client
  discovery: true
  topic_prefix: wiegand-gateway

web_server:
  port: 80
  version: 3
  include_internal: true 
  local: true

# ================= GLOBALE VARIABLEN ================= 
globals:
  - id: pin_buffer
    type: std::string
    restore_value: no
    initial_value: '""'
  
  - id: terminal_location_storage
    type: std::string
    restore_value: yes
    initial_value: '"Eingangsbereich"' 

# ================= AUTOMATISCHE RESETS ================= 
script:
  - id: clear_pin_timeout
    mode: restart
    then:
      - delay: 5s
      - lambda: 'id(pin_buffer).clear();'
      - text_sensor.template.publish: {id: gateway_status, state: "Bereit"}
    
  - id: reset_display_script
    mode: restart
    then:
      - delay: 10s 
      - text_sensor.template.publish: {id: last_access_event, state: "---"}
      - text_sensor.template.publish: {id: gateway_status, state: "Bereit"}
      - text_sensor.template.publish: {id: raw_scan_preview, state: "---"}

# ================= WEB INTERFACE ELEMENTE ================= 

text:
  - platform: template
    name: "01. Montageort ändern"
    id: location_input
    icon: "mdi:square-edit-outline"
    mode: text
    internal: true 
    lambda: 'return {};' 
    set_action:
      then:
        - lambda: |-
            std::string input = x;
            input.erase(0, input.find_first_not_of(" "));
            input.erase(input.find_last_not_of(" ") + 1);

            if (input.length() > 0 && input.length() <= 16) {
              id(terminal_location_storage) = input;
              id(terminal_location_display).publish_state(input);
              id(gateway_status).publish_state("Gespeichert! Neustart...");
            } else if (input.length() > 16) {
              id(gateway_status).publish_state("FEHLER: Max 16 Zeichen!");
              id(reset_display_script).execute(); 
            } else {
              id(gateway_status).publish_state("FEHLER: Name leer!");
              id(reset_display_script).execute();
            }
        - if:
            condition:
              lambda: |-
                std::string input = x;
                input.erase(0, input.find_first_not_of(" "));
                input.erase(input.find_last_not_of(" ") + 1);
                return input.length() > 0 && input.length() <= 16;
            then:
              - delay: 2000ms
              - button.press: restart_button

text_sensor:
  - platform: template
    name: "02. Wichtiger Hinweis"
    id: renaming_notice_1
    icon: "mdi:alert-circle-outline"
    internal: true
    lambda: 'return {"Nach Änderung erfolgt ein automatischer Neustart."};'

  - platform: template
    name: "03. "
    id: renaming_notice_2
    icon: "mdi:alert-circle-outline"
    internal: true
    lambda: 'return {"Max. 16 Zeichen! Umlaute & Leerzeichen vermeiden!"};'

  - platform: template
    name: "04. Letzter Scan (Rohdaten)"
    id: raw_scan_preview
    icon: "mdi:barcode-scan"
    internal: true

  - platform: template
    name: "Aktueller Montageort"
    id: terminal_location_display
    icon: "mdi:map-marker-radius"

  - platform: template
    name: "Systemstatus"
    id: gateway_status
    icon: "mdi:information-outline"

  - platform: template
    name: "W-Schnittstelle"
    id: last_access_event
    icon: "mdi:ethernet"

  - platform: wifi_info
    ip_address:
      name: "IP Adresse"
      icon: "mdi:ip-network"

binary_sensor:
  - platform: status
    name: "Gateway Online"
    icon: "mdi:check-network"

sensor:
  - platform: wifi_signal
    name: "WLAN Signal"
    update_interval: 60s
    icon: "mdi:wifi"

button:
  - platform: restart
    name: "Gateway Neustart"
    id: restart_button
    icon: "mdi:restart"

# ================= HARDWARE AUSGÄNGE ================= 
output:
  - platform: gpio
    pin: GPIO2
    id: push_pin_output
    inverted: true

light:
  - platform: binary
    id: reader_led
    name: "Terminal LED"
    output: push_pin_output
    icon: "mdi:led-on"
    on_turn_on:
      - delay: 1s
      - light.turn_off: reader_led

# ================= WIEGAND LOGIK ================= 
wiegand:
  - id: wiegand_reader
    d0: 5
    d1: 6
    on_raw:
      then:
        - lambda: |-
            char raw_chars[20];
            sprintf(raw_chars, "%llu", value);
            id(raw_scan_preview).publish_state(raw_chars);

            auto publish_data = [&](std::string type, std::string val) {
              std::string loc = id(terminal_location_storage);
              std::string topic = "wiegand/" + loc + "/event";
              topic.erase(std::remove(topic.begin(), topic.end(), ' '), topic.end());

              if (id(mqtt_client).is_connected()) {
                id(mqtt_client).publish_json(topic, [=](JsonObject root) {
                  root["type"] = type;
                  root["value"] = val;
                  root["location"] = loc;
                });
              }
              id(last_access_event).publish_state(val);
              id(gateway_status).publish_state("An " + loc + " gesendet");
              id(reset_display_script).execute();
            };

            if (bits >= 24) {
              publish_data("rfid", raw_chars);
            }
            
            if (bits == 4 || bits == 8) {
              if (value <= 9) {
                id(pin_buffer) += std::to_string(value);
                id(gateway_status).publish_state("Eingabe...");
                id(clear_pin_timeout).execute();
              } else if (value == 11) {
                if (!id(pin_buffer).empty()) {
                  publish_data("pin", id(pin_buffer));
                  id(pin_buffer).clear();
                }
              } else if (value == 10) {
                id(pin_buffer).clear();
                id(gateway_status).publish_state("Abgebrochen");
                id(reset_display_script).execute();
              }
            }